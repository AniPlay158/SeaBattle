#include <iostream>
#include <time.h>//для работы с датой и временем
#include <windows.h>//включает функции WinAPI sleep(), beep() и т.д
#include <conio.h>//для создания текстового интерфейса пользователя
#include "Header.h"

using namespace std;

int main()
{
	setlocale(LC_ALL, "");
	srand(time(NULL));
	char option[2][30] = { "АВТОМАТИЧЕСКАЯ РАССТАНОВКА","РУЧНАЯ РАССТАНОВКА" };
	int ship_pos[12][24] = { 0 }; //двумерный массив благодоря которому можно будет отслеживать что есть на  поле(кораблики\место снаряда и тд)
	int enemy_ship_pos[12][24] = { 0 }; //двумерный массив благодоря которому можно будет отслеживать что есть на  поле(кораблики\место снаряда и тд)
	Ships* characteristic = new Ships[20]; //создаём 10-ть корабликов характеристики которых описаны в структуре
	LoadCharactShips(characteristic); //загрука характеристик корабликов (изначальное положение и количество палуб)
	int key = 1;//переменная для записи нажатой клавиши
	int y = 2;//позиция по Y
	int x = 2;//позиция по X
	int num = 0;//номер кораблкиа
	int change = 1;//номер расстановки который будет использован
	int A = 0;//дополнительная переменная для меню
	int xx = 37;//дополнительная перемнная для записи положения курсора на вражеском поле
	int yy = 2;//дополнительная перемнная для записи положения курсора на вражеском поле
	int up = 0;//переменная которая поможет правильно добивать наши кораблики
	int down = 0;//переменная которая поможет правильно добивать наши кораблики
	int over = 0;
	bool manual_placement = true, your_turn = 0 + rand() % 2, start = false;//start - переменная для проверки на начало боя. manual_placement - тип расстановки который будет использован. 
	Avake(); //Вывыдим надпись "МОРСКОЙ БОЙ" на экран
	Sleep(1500); //ждём 1.5 секунды
	setColor(White, Black); //Устанавливаем цвет текста (белый на чёрном)
	system("cls"); //очищяем консоль
	Paint(option, change);
	do //запускаем цикл
	{
		key = _getch(); //получаем номер нажатой клавиши
		switch (key) //запускаем свитч
		{
		case Up: //если нажали "Стрелочка вверх"
			if (y > 0) //если "y" больше 0
			{
				y--; //вычитаем из значение по "y" 1
				change = y; //выбранный пункт
				Paint(option, change); //вывод пунктов на экран
			}
			break;
		case Down: //если нажали "Стрелочка вниз"
			if (y < 1) //если "y" меньше 1
			{
				y++; //прибавляем к значению по "y" 1
				change = y; //выбранный пункт
				Paint(option, change); //вывод пунктов на экран
			}
			break;
		case Enter:
			do
			{
				switch (change)
				{
				case 0: // ксли 0
					manual_placement = false; //автоматическая расстанвкоа
					A++; //чтобы заврешить цикл
					break;
				case 1:
					manual_placement = true; //ручная расстановка
					A++; //чтобы заврешить цикл
					y++; //прибавляем к значению по "y" 1
					break;
				}
			} while (key != Enter);
		}
	} while (A < 1);
	system("cls"); //очищяем консоль
	CreatField(0, 0, 2); //создаём игровое поле
	x = 2, y = 2;
	if (manual_placement == false) //если выбрана автоматическая расстановка
	{
		auto_arrangement(characteristic, ship_pos, 0); //передаём необходимые значения для того что автоматически расставить кораблки
		PaintPos(ship_pos, 2, 0); //перерисовываем игровую локации с учетём внесенных изменений (поставили кораблик
		start = true; //начинаем игру
	}
	else if (manual_placement == true && num < 10) //ручная расстановка
	{
		do //запускаем цикл в котором при нажатии на ту или иную клавишу будеи делать то или иное дейстивие
		{
			PaintPos(ship_pos, 2, 0); //перерисовываем игровую локации с учетём внесенных изменений (поставили кораблик)
			SetCursor(x, y); //ставим курсор на позицию изменяемых ниже переменных (X, Y)
			setColor(Black, Black); //устанавливаем черный цвет так как таким цветом будет выводиться кораблик
			if (characteristic[num].horizontal == true) //если кораблик имеет горизонтальное положение
			{
				for (size_t i = 0; i < characteristic[num].deck; i++) //запускаем цикл который будет отрисовыввать кораблик с нужным колличеством палуб
				{
					cout << "++"; //2 "+" так как одна клеточка в ширину в игре равна 2-ум клеточкам в ширину в консоли
				}
			}
			else if (characteristic[num].horizontal == false)
			{
				y += characteristic[num].deck; //изменяем позицию по "y" на то сколько палуб у кораблика
				for (size_t i = 0; i < characteristic[num].deck; i++)  //запускаем цикл который будет отрисовыввать кораблик с нужным колличеством палуб
				{
					cout << "++"; //2 "+" так как одна клеточка в ширину в игре равна 2-ум клеточкам в ширину в консоли
					y--; //спускаемся вниз на одну клеточку
					SetCursor(x, y); //устанавливаем позицию на одну клеточку ниже и на изначальное по Х
				}
			}
			key = _getch();//функция возвращает номер нажатой клавиши
			switch (key) //Выполняем различные функции в соответствии с нажатой клавишью
			{
			case Left: //если нажали "Стрелочка влево"
				if (x > 3) //позиция до которой разрешено перемещение в лево
				{
					x -= 2; //меняем значение по Х на -2 так как одна клеточка в игре равна двум в консоли
				}
				break;
			case Right: //если нажали "Стрелочка вправо"
				if (characteristic[num].horizontal == true) //Если кораблик имеет горизонтальное положение
				{
					if (x < 22 - characteristic[num].deck * 2) // проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
					{
						x += 2; //меняем значение переменной Х на +2 так как одна клеточка в игре равна двум в консоли
					}
				}
				else  //Если кораблик имеет вертикальное положение
				{
					if (x < 20) // проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
					{
						x += 2; //меняем значение переменной Х на +2 так как одна клеточка в игре равна двум в консоли
					}
				}
				break; //закрыли этот кейс
			case Up: //если нажали "Стрелочка вверх"
				if (y > 2) //позиция до которой разрешено перемещение вверх
				{
					y--;  //меняем значение по Y на -1
				}
				break; //закрыли этот кейс
			case Down: //если нажали "Стрелочка вних"
				if (characteristic[num].horizontal == false) //Если кораблик имеет вертикальное положение
				{
					if (y < 12 - characteristic[num].deck) // проверяем не достиг ли он позиции до которой ему можно передвигаться (так как он 4-х палубный, и его нужно ограничивать на 3 клеточки ранее)
					{
						y++;  //меняем значение по Y на +1
					}
				}
				else
				{
					if (y < 11) // проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
					{
						y++;  //меняем значение по Y на +1
					}
				}
				break; //закрыли этот кейс
			case Q: //если нажали "Q"
				characteristic[num].horizontal = !characteristic[num].horizontal; //изменяем ориентацию кораблика на противоположную
				if (characteristic[num].horizontal == false && y + characteristic[num].deck >= 13)
					//проверяем заденит ли кораблик границу по вертикале при перевороте, если его не отодвинуть
				{
					y -= y + characteristic[num].deck - 12; //если да, то заранее изменем его положение чтобы он не прошел сковзь границы поля по вертикали
				}
				else if (characteristic[num].horizontal == true && x + characteristic[num].deck * 2 >= 24)
					//проверяем заденит ли кораблик границу по вертикале при перевороте, если его не отодвинуть
				{
					x -= (x + characteristic[num].deck * 2) - 22; //если да, то заранее изменем его положение чтобы он не прошел сковзь границы поля по вертикали
				}
				for (size_t i = 0; i < 10 - num; i++) //изменяем ориентацию так же и для последующих корабликов
				{
					characteristic[num + i].horizontal = characteristic[num].horizontal; // заранее изменяем положение следующего кораблика на то которое мы выбрали сейчас
				}
				break; //закрыли этот кейс
			case Enter: //если нажали "Enter"
				if (characteristic[num].horizontal == true && ship_pos[y - 1][x] == 0 && ship_pos[y - 1][x + characteristic[num].deck * 2 - 2] == 0)
				{
					characteristic[num].x = x + 2, characteristic[num].y = y;
					for (size_t q = 0; q < 3; q++) //выполнеям нижеуказанный код 3 раза так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
					{
						for (size_t w = 1; w < characteristic[num].deck * 3 + 1; w++) //выполнеям нижеуказанный код 11 раз так как надо чтобы 4-х палубный кораблик полностью окупировался
						{
							ship_pos[y - 2 + q][x - 3 + w] = 1; //меняем значение окупируемых позиций в двумерном массиве который будем прверять на различные цифорки, на "1"
						}
					}
					for (int g = 0; g < 2 * characteristic[num].deck; g++) //выполнеям нижеуказанный код 8 раз так как кораблик 4-х палубный, а одна палуба по горизонатали 2 клеточки
					{
						ship_pos[y - 1][x + g] = 13 - num;  //меняем значение позиций в двумерном массиве который будем прверять на различные цифорки, на "2"
					}
					num++; //переходим к следующему кораблику
				}
				if (characteristic[num].horizontal == false && ship_pos[y - 1][x] == 0 && ship_pos[y + characteristic[num].deck - 2][x] == 0)
				{
					characteristic[num].x = x + 2, characteristic[num].y = y;
					for (size_t q = 0; q < characteristic[num].deck + 2; q++) //выполнеям нижеуказанный код 6 раз так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
					{
						for (size_t w = 0; w < 6; w++) //выполнеям нижеуказанный код 6 раз так как нам необходимо окупировать кораблик чтобы они не стояли вполтную к друг другу
						{
							ship_pos[y - 2 + q][x - 2 + w] = 1; //меняем значение окупируемых позиций в двумерном массиве который будем прверять на различные цифорки, на "1"
						}
					}
					for (int g = 0; g < characteristic[num].deck; g++) //выполнеям нижеуказанный код 3 раза так как кораблик 3-х палубный
					{
						for (int n = 0; n < 2; n++) //выполняем нижеуказаныый код 2 раза так как нам нужно поменять занчения в массиве для 2-ух клеточек (одной палубы)
						{
							ship_pos[y - 1 + g][x + n] = 13 - num; //меняем значение позиций в двумерном массиве который будем прверять на различные цифорки, на "2"
						}
					}
					num++; //переходим к следующему кораблику
				}
			}
			start = true;//запускаем игру
		} while (num <= 9); //цикл работает до тех пор пока количество расставленных корабликов не равно 10
	}
	Sleep(20);
	CreatField(1, 35, 4); //создаём игровое поле
	auto_arrangement(characteristic, enemy_ship_pos, 10); //автоматическая расстанвока для вражеских корабликов
	PaintPos(enemy_ship_pos, 37, 15); //отрисовка вражеских кораблей/поля
	do
	{
		if (your_turn == true) //если моя очередь атаковать
		{
			do //запускаем цикл в котором при нажатии на ту или иную клавишу будеи делать то или иное дейстивие
			{
				x = xx, y = yy; //переменная которая будет запоминать где находился курсор 
				PaintPos(enemy_ship_pos, 37, 15); //перерисовываем игровую локации с учетём внесенных изменений (поставили кораблик)
				setColor(DarkGray, DarkGray); //устанавливаем черный цвет так как таким цветом будет выводиться кораблик
				SetCursor(x, y); //ставим курсор на позицию изменяемых ниже переменных (X, Y)
				cout << "++"; //2 "+" так как одна клеточка в ширину в игре равна 2-ум клеточкам в ширину в консоли
				key = _getch();//функция возвращает номер нажатой клавиши
				switch (key) //Выполняем различные функции в соответствии с нажатой клавишью
				{
				case Left: //если нажали "Стрелочка влево"
					if (x > 38) //позиция до которой разрешено перемещение в лево
					{
						x -= 2; //меняем значение по Х на -2 так как одна клеточка в игре равна двум в консоли
						xx = x; //запоминаем положение курсора
					}
					break;
				case Right: //если нажали "Стрелочка вправо"
					if (x < 55) // проверяем не достиг ли он позиции до которой ему можно передвигаться(чтобы он не вышел за границы поля)
					{
						x += 2; //меняем значение переменной Х на +2 так как одна клеточка в игре равна двум в консоли
						xx = x; //запоминаем положение курсора
					}
					break; //закрыли этот кейс
				case Up: //если нажали "Стрелочка вверх"
					if (y > 2) //позиция до которой разрешено перемещение вверх
					{
						y--;  //меняем значение по Y на -1
						yy = y; //запоминаем положение курсора
					}
					break; //закрыли этот кейс
				case Down: //если нажали "Стрелочка вних"
					if (y < 11) //позиция до которой разрешено перемещение вниз
					{
						y++;  //меняем значение по Y на +1
						yy = y; //запоминаем положение курсора
					}
					break;
				case Enter:
					if (enemy_ship_pos[y - 1][x - 35] >= 4) //проверяем позицию по которой мы выстрельнули на наличие корабликов
					{
						for (size_t i = 0; i < 2; i++) //если это так то мызаменяем в клеточке номерок кораблика на "3"
						{
							enemy_ship_pos[y - 1][x - 35 + i] = 3; // изменяем значение
							explosion(characteristic, enemy_ship_pos, 10, over); //проверяем на уничтожение
						}
						Meny(9); //вывод реплики на экран
						Sleep(500); //небольшая пауза
					}
					else if (enemy_ship_pos[y - 1][x - 35] < 2) //Если на позиции по которой был произведён огонь ничего нету 
					{
						for (size_t i = 0; i < 2; i++) //если это так то мызаменяем в клеточке номерок кораблика на "2"
						{
							enemy_ship_pos[y - 1][x - 35 + i] = 2; // изменяем значение
						}
						Sleep(500); //небольшая пауза
						Meny(5); //вывод реплики на экран
						your_turn = false; //очередь атаки противника
					}
					break;
				}
			} while (key != Enter); //выполнять код который демонстрируется в цикл до тех пор пока не нажата клавиша "Enter"
		}
		if (your_turn == false) //если ход противника
		{
			Sleep(0 + rand() % 400); //небольшая пауза
			Meny(0); //вывод реплики на экран
			PaintPos(ship_pos, 2, 0); //перерисовываем наше поле
			Sleep(0 + rand() % 400); //небольшая пауза
			x = (2 + rand() % 10) * 2, y = 2 + rand() % 10; //случайным образом выдаём кооординату по котороой будет происходить атака
			if (ship_pos[y - 1][x - 1] >= 4) //проверяем позицию по которой мы выстрельнули на наличие корабликов
			{
				for (size_t i = 0; i < 2; i++) //если это так то мызаменяем в клеточке номерок кораблика на "3"
				{
					ship_pos[y - 1][x - 2 + i] = 3;  // изменяем значение
					explosion(characteristic, ship_pos, 0, over); //проверяем на уничтожение
				}
				Meny(2); //вывод реплики на экран
				Sleep(0 + rand() % 750); //небольшая пауза
			}
			else if (ship_pos[y - 1][x - 1] <= 2) //Если на позиции по которой был произведён огонь ничего нету 
			{
				for (size_t i = 0; i < 2; i++) //если это так то мызаменяем в клеточке номерок кораблика на "2"
				{
					ship_pos[y - 1][x - 2 + i] = 2; //изменяем значение
				}
				Meny(1); //вывод реплики на экран
				Sleep(0 + rand() % 750); //небольшая пауза
				your_turn = true; //моя очередь атаки
			}
		}
	} while (over == 0);
	PaintPos(ship_pos, 2, 0);
	PaintPos(enemy_ship_pos, 37, 15); //перерисовываем игровую локации с учетём внесенных изменений (поставили кораблик)
	if (over == 2) //
	{
		Meny(7);
	}
	else
	{
		Meny(3);
	}
	Sleep(500000);
}
